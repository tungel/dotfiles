"===============================================================================
" https://github.com/everbot/dotfiles
"
" My own note of using VIM:
"   * use gvim as it has better font rendering
"   * gvim can auto-reload a file if it's changed externally
"     vim can't do that (???!!!)
"   * use Monospace font
"   * font size is 10
"===============================================================================
"

" Read essential configuration from the mini file
source ~/.vimrc-mini

"===============================================================================
"---begin pathogen plugin
execute pathogen#infect()

" If you want to be able to access the documentation from within vim, you'll
" also need to generate helptags
call pathogen#helptags()

"---end pathogen plugin
"===============================================================================


"===============================================================================
"---begin easy-motion {{{

"let g:EasyMotion_do_mapping = 0 " Disable default mappings
"map <Leader> <Plug>(easymotion-prefix)

let g:EasyMotion_smartcase = 0

nmap s <Plug>(easymotion-s2)
nmap t <Plug>(easymotion-t2)

map  / <Plug>(easymotion-sn)
omap / <Plug>(easymotion-tn)

" These 'n' & 'N' mappings are options. You do not have to map 'n' & 'N' to
" EasyMotion.  " Without these mappings, 'n' & 'N' works fine. (These mappings
" just provide " different highlight method and have some other features )
map  n <Plug>(easymotion-next)
map  N <Plug>(easymotion-prev)


"map <Leader>l <Plug>(easymotion-lineforward) "comment this out, interfere with
"latex
map <Leader>j <Plug>(easymotion-j)
map <Leader>k <Plug>(easymotion-k)
map <Leader>h <Plug>(easymotion-linebackward)
let g:EasyMotion_startofline = 0 " keep cursor colum when JK motion

"---end easy-motion }}}
"===============================================================================


"===============================================================================
"---begin nerdtree {{{
"autocmd vimenter * NERDTree "auto open nerdtree upon vim launch
" use Ctrl+n to open nerdtree
map <C-n> :NERDTreeToggle<CR>

" fix can't navigate to directory using enter key, due to odd symbols infront
" of directory name
let NERDTreeDirArrows=0

" don't display compile output stuffs
let NERDTreeIgnore=['.class$[[file]]', '.o$[[file]]']

" split and vsplit behave similar with Unite candidate window shortcut
let NERDTreeMapOpenSplit='s'
let NERDTreeMapOpenVSplit='v'

"open nerdtree based on the directory of the current buffer, the cursor will be
"placed at the current opened file
map <silent> <Leader>r :NERDTreeFind<cr>
"---end nerdtree }}}
"===============================================================================


"match Todo /^ \+/

"highlight current line
color molokai
"color Monokai-Refined


"set linespace=2

"===============================================================================
" for solarized theme
"
"syntax enable
"if has('gui_running')
"    set background=light
"else
"    set background=dark
"endif
"colorscheme solarized
"===============================================================================


" automatic reloading of .vimrc, so we don't need to close the .vimrc
" for vim to apply new settings in that file
" currently, this interfeer with identLine and vim-airline (after save the
" .vimrc file, those plugin lost their visual.
"autocmd! bufwritepost .vimrc source %


"===============================================================================
"---begin unite.vim {{{
"usage:
" :Unite line
" :Unite tab


" "test" ignores test directory/file only.
" "test/" ignores test directory and inner files.
" ignore everything at first
let s:unite_mru_ignores = ['*']
" add white list of candidates not to be ignored
let s:unite_mru_whites = ['Test.java',
                    \ '**/Dropbox/dev/**',
                    \ '*.md',
                    \ 'pacman.log',
                    \ '**/dotfiles/**']
call unite#custom#source('file_mru', 'ignore_globs', s:unite_mru_ignores)
call unite#custom#source('file_mru', 'white_globs', s:unite_mru_whites)
" call unite#custom#source('file_rec,file_rec/async,file_mru,file,buffer,grep',
"   \ 'ignore_globs', unite#get_all_sources('file_rec')['ignore_globs'] +
"   \ s:unite_mru_ignores)
" call unite#custom#source('file_rec,file_rec/async,file_mru,file,buffer,grep',
"   \ 'white_globs', unite#get_all_sources('file_rec')['white_globs'] +
"   \ s:unite_mru_whites)

" The below setting works well to ignore certain patterns in the white_globs list
" \ '\/.vim\/bundle\/.\+tags$',  : match .vim/bundle/..tags
call unite#custom#source('file_mru', 'ignore_pattern',
            \ join([
            \ '\.cache',
            \ '\/.vim\/bundle\/',
            \ '\/everbot\.github\.io\/',
            \ '^\/run'],
            \ '\|'
            \ )
            \ )

" For file_rec/async source: Ignore all files under tmp directory of Rails app
call unite#custom#source('file_rec/async', 'ignore_pattern',
            \ join([
            \ '\.cache',
            \ '\/tmp\/cache\/',
            \ '\/tmp\/pids\/',
            \ '\/tmp\/sessions\/',
            \ '\/tmp\/sockets\/'],
            \ '\|'
            \ )
            \ )

nnoremap <C-Space> :Unite -start-insert<CR>

" custom profile:
" \   'direction': 'botright',
" 'direction': 'botright', 'topleft'
" 'prompt_direction': 'top', 'below'
" \   'prompt': '» ',
call unite#custom#profile('default', 'context', {
\   'startinsert': 1,
\   'prompt': '>> ',
\   'prompt_direction': 'top',
\   'direction': 'topleft',
\ })
"
" Set "-no-quit" automatically in grep unite source.
call unite#custom#profile('source/grep', 'context', {
\   'no_quit' : 1
\ })


" call unite#util#set_default(
" \ 'g:unite_source_grep_command', 'grep')
" call unite#util#set_default(
" \ 'g:unite_source_grep_default_opts', '-inH')
" " \ 'g:unite_source_grep_default_opts', '-inH --directories=recurse')
" call unite#util#set_default('g:unite_source_grep_recursive_opt', '-r')
" call unite#util#set_default('g:unite_source_grep_max_candidates', 100)
" call unite#util#set_default('g:unite_source_grep_search_word_highlight', 'Search')
" call unite#util#set_default('g:unite_source_grep_encoding', 'char')
"
let g:unite_source_grep_command = "grep"
let g:unite_source_grep_recursive_opt = "-R"
let g:unite_source_grep_default_opts = '-inH'
" let g:unite_source_grep_default_opts = '-ir'
" nnoremap <space>/ :Unite grep:.:-iR:tung<cr>
" nnoremap <space>/ :Unite grep:.::tung<cr>
" nnoremap <space>/ :Unite grep:.<cr>

nnoremap <leader><F8> :Unite grep:.<cr>

" Use F8 to grep from the root level of the current git repo
nnoremap <F8> :Unite grep/git:/<cr>

" For ack.
" Using ack-grep as recursive command.
let g:unite_source_rec_async_command = 'find'




" access recently edited files
nnoremap <silent> <Leader>m :Unite -buffer-name=recent -winheight=10 -start-insert file_mru<cr>

" navigates current open buffers
nnoremap <Leader>b :Unite -buffer-name=buffers -winheight=10 -start-insert buffer<cr>

" open Unite file browser
nnoremap <Leader>f :Unite file_rec/async -start-insert<cr>

" open bookmark
nnoremap <silent> <Leader>a :Unite -buffer-name=bookmarks -start-insert bookmark<CR>

" yank history
nnoremap <Leader>y :<C-u>Unite -buffer-name=yank history/yank<cr>

" Unite outline (support markdown quite well!)
nnoremap <Leader>o :Unite outline -start-insert<cr>



" control where the unite buffer will appear
"let g:unite_split_rule = "botright"
" let g:unite_split_rule = "top"
" let g:unite_split_rule = "right"

" open a buffer in new tab or switch to existing tab by default
" call unite#custom_default_action('file', 'tabopen')
call unite#custom_default_action('file', 'tabswitch')
call unite#custom_default_action('buffer', 'tabswitch')


"fuzzy search within a file using <Leader>q
call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_rank'])
" call unite#custom#source('file,file/new,buffer,file_rec,line', 'matchers', 'matcher_fuzzy')
call unite#custom#source('file,file/new,buffer,file_rec', 'matchers', 'matcher_fuzzy')
" call unite#custom#source('line', 'matchers', 'matcher_default')
call unite#custom#source('line', 'matchers', 'matcher_glob')
" nnoremap <C-k> :<C-u>Unite -buffer-name=search -start-insert line<cr>
nnoremap <Leader>q :<C-u>Unite -buffer-name=search -start-insert line -auto-preview<cr>
" nnoremap <Leader>q :<C-u>Unite -buffer-name=search -start-insert line -auto-preview -vertical-preview<cr>

" Use Ctrl+l to refresh the directory listing in file in Unite candidate window
autocmd FileType unite call s:unite_my_settings()
function! s:unite_my_settings()"{{{
  " Overwrite settings.
  nmap <buffer> <C-l>      <Plug>(unite_redraw)

  " these mapping are used in the Unite candidate window
  nnoremap <buffer><expr> t unite#do_action('tabswitch')
  nnoremap <buffer><expr> s unite#do_action('splitswitch')
  nnoremap <buffer><expr> v unite#do_action('vsplitswitch')

  " Enable navigation with control-j and control-k in insert mode
  imap <buffer> <C-j>   <Plug>(unite_select_next_line)
  imap <buffer> <C-k>   <Plug>(unite_select_previous_line)
endfunction"}}}


let g:unite_source_menu_menus = {}
let g:unite_source_menu_menus.git = {
    \ 'description' : '            gestionar repositorios git
        \                            ⌘ [espacio]g',
    \}
let g:unite_source_menu_menus.git.command_candidates = [
    \['▷ tig                                                        ⌘ ,gt',
        \'normal ,gt'],
    \['▷ git status       (Fugitive)                                ⌘ ,gs',
        \'Gstatus'],
    \['▷ git diff         (Fugitive)                                ⌘ ,gd',
        \'Gdiff'],
    \['▷ git commit       (Fugitive)                                ⌘ ,gc',
        \'Gcommit'],
    \['▷ git log          (Fugitive)                                ⌘ ,gl',
        \'exe "silent Glog | Unite quickfix"'],
    \['▷ git blame        (Fugitive)                                ⌘ ,gb',
        \'Gblame'],
    \['▷ git stage        (Fugitive)                                ⌘ ,gw',
        \'Gwrite'],
    \['▷ git checkout     (Fugitive)                                ⌘ ,go',
        \'Gread'],
    \['▷ git rm           (Fugitive)                                ⌘ ,gr',
        \'Gremove'],
    \['▷ git mv           (Fugitive)                                ⌘ ,gm',
        \'exe "Gmove " input("destino: ")'],
    \['▷ git push         (Fugitive, salida por buffer)             ⌘ ,gp',
        \'Git! push'],
    \['▷ git pull         (Fugitive, salida por buffer)             ⌘ ,gP',
        \'Git! pull'],
    \['▷ git prompt       (Fugitive, salida por buffer)             ⌘ ,gi',
        \'exe "Git! " input("comando git: ")'],
    \['▷ git cd           (Fugitive)',
        \'Gcd'],
    \]

" 2015-04-30 below line cause `[m` motion slow
" nnoremap <silent>[menu]g :Unite -silent -start-insert menu:git<CR>

let g:unite_source_tag_max_name_length=25
let g:unite_source_tag_max_fname_length=50
let g:unite_source_tag_relative_fname=1

"---end unite.vim }}}
"===============================================================================


"===============================================================================
" begin vim-airline {{{

set laststatus=2

" use Powerline font to enable the nice arrow icons
set encoding=utf-8 " to use the Powerline font
let g:airline_powerline_fonts = 1

" display nice icon ontop
" currently having problem messing up the top tabs indicator after a buffer
" is closed
let g:airline#extensions#tabline#enabled = 1

" Just show the filename (no path) in the tab
let g:airline#extensions#tabline#fnamemod = ':t'

" show number of buffer in the current tab in tabline status
" let g:airline#extensions#tabline#tab_nr_type = 0

" show tab number in tabline status
let g:airline#extensions#tabline#tab_nr_type = 1

" let g:airline#extensions#tabline#buffer_nr_show = 1

let g:Powerline_symbols="fancy"

" make tabline separator straight instead of the nice arrow icon
" let g:airline#extensions#tabline#left_sep = ' '
"let g:airline#extensions#tabline#left_alt_sep = '|'

" when there is only 1 tab open, vim-airline will display all buffers in the
" tabline, we can switch to a buffer by :bn or :bp
" end vim-airline }}}
"===============================================================================


"===============================================================================
"begin indentLine {{{

if has('gui_running')
    "let g:indentLine_color_gui = '#353833'
    let g:indentLine_color_gui = '#2E322D'
else
    let g:indentLine_color_term = 239
endif

let g:indentLine_char = '┊'

"end indentLine }}}
"===============================================================================


"===============================================================================
"---begin vim-latex plugin {{{
filetype plugin indent on "REQUIRED. This makes vim invoke Latex-Suite when you open a tex file.
set grepprg=grep\ -nH\ $*
let g:tex_flavor = "latex"
let g:Tex_DefaultTargetFormat = 'pdf'
let g:Tex_MultipleCompileFormats='pdf, aux'

" use synctex
let g:Tex_CompileRule_pdf = 'pdflatex -interaction=nonstopmode -synctex=1 $*'

" to ignore quickfix window automatically open when there is warning, it's
" really annoying!
let g:Tex_IgnoredWarnings =
    \'Underfull'."\n".
    \'Overfull'."\n".
    \'specifier changed to'."\n".
    \'You have requested'."\n".
    \'Missing number, treated as zero.'."\n".
    \'There were undefined references'."\n".
    \'Citation %.%# undefined'."\n".
    \'Double space found.'."\n".
    \'LaTex Warning'."\n"
let g:Tex_IgnoreLevel = 9

" which program to use to open pdf file
" let g:Tex_ViewRule_pdf = 'zathura'
" let g:Tex_ViewRule_pdf = "zathura -s -x 'gvim --servername SYNCTEX --remote +%{line} %{input}'".expand("%:p:r").".pdf"
let g:Tex_ViewRule_pdf = "zathura"

" let g:Tex_ViewRule_ps = 'okular'
" let g:Tex_ViewRule_pdf = 'okular'
" let g:Tex_ViewRule_dvi = 'okular'

" In short you should be able to change three global variables to get rid of all folding
"let Tex_FoldedSections=""
"let Tex_FoldedEnvironments=""
"let Tex_FoldedMisc=""

"to disable display inline math notation
let g:tex_conceal = ""

function! SyncTexForward()
     " let execstr = "silent !okular --unique %:p:r.pdf\\#src:".line(".")."%:p &"
     " let execstr = "silent !zathura --synctex-forward 200:1:thesis.tex thesis.pdf"
     let execstr = "silent !zathura --synctex-forward ".line(".").":1:".expand("%:p:r").".tex ".expand("%:p:r").".pdf"
     exec execstr
endfunction
nmap <Leader>1 :call SyncTexForward()<CR>

"---end vim-latex }}}
"===============================================================================

"===============================================================================
"---begin fugitive {{{
nmap <leader>gs :Gstatus<cr>
nmap <leader>gc :Gcommit<cr>
nmap <leader>gp :Gpush<cr>
"---end fugitive }}}
"===============================================================================


"===============================================================================
"---begin supertab plugin
"currently not using supertab
"TODO: try out YouCompleteMe plugin
"
"let g:SuperTabDefaultCompletionType = "context"
"let g:SuperTabDefaultCompletionType = "<C-X><C-O>"

"---end supertab
"===============================================================================



" vim-indent guide:
" usage: <leader>ig to toggle/untoggle displaying the ident guide
"let g:indent_guides_auto_colors = 0
"autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd  guibg=red   ctermbg=3
"autocmd VimEnter,Colorscheme * :hi IndentGuidesEven guibg=blue ctermbg=4




"===============================================================================
"---begin cursor highlight
" make the cursor at the current line different, highlight current line
if has('gui_running')
    "set cursorline "this make movement quite slow on low spec computer
endif

"should not set color explicitly, leave it to the theme configuration
"hi CursorLine term=bold cterm=bold guibg=Grey40


"------------------
"let g:boostmove=0
"set updatetime=50
"au CursorMoved * call BoostMoveON()
"au CursorMovedI * call BoostMoveON()
"au CursorHold * call BoostMoveOFF()
"au CursorHoldI * call BoostMoveOFF()
"
"function BoostMoveON()
"    if (g:boostmove == 0)
"        let g:boostmove=1
"        setlocal nocursorline
"    endif
"endfunction
"
"function BoostMoveOFF()
"    if g:boostmove==1
"        let g:boostmove=0
"        setlocal cursorline
"    endif
"endfunction


"use Ctrl+spacebar to temporary display the crosshair cursor for awhile and
"disappear
"http://briancarper.net/blog/590/cursorcolumn--cursorline-slowdown
function! CursorPing()
    set cursorline cursorcolumn
    redraw
    sleep 50m
    set nocursorline nocursorcolumn
endfunction

" seldom use this, so use C-Space for Unite because it's more useful!
" nmap <C-Space> :call CursorPing()<CR>
"---end cursor highlight
"===============================================================================

"===============================================================================
"---begin tcomment-vim

" use Ctrl+m to toggle comment/uncomment a block of code
"vmap <C-m> gc

" Disable tComment to escape some entities
"let g:tcomment#replacements_xml={}

"---end tcomment-vim
"===============================================================================


"===============================================================================
"---begin neocomplete {{{

"disable AutoComplPop
let g:acp_enableAtStartup = 0


" disable annoying preview window of the current item in the completion list
" especially in clojure file
set completeopt-=preview

let g:neocomplete#enable_at_startup = 1
let g:neocomplete#enable_fuzzy_completion = 1
let g:neocomplete#enable_ignore_case = 1

let g:neocomplete#max_list = 15
let g:neocomplete#enable_auto_select = 1

" Fix keyword length violate min and max value
" https://github.com/Shougo/neocomplete.vim/issues/359
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<BS>"


" disable omni completion for Clojure because it's so slow!
if !exists('g:neocomplete#sources#omni#input_patterns')
    let g:neocomplete#sources#omni#input_patterns = {}
endif
let g:neocomplete#sources#omni#input_patterns.clojure = ''

" comment out the below line because it interfere with delimitMate of auto
" insert matching brace - 2015-03-12
" let g:neocomplete#enable_auto_delimiter = 1

" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 4
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'
let g:neocomplete#min_keyword_length = 3

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType eruby,html,markdown,md setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete


" Enable auto display a completion list candidates, but it's slow
" if !exists('g:neocomplete#force_omni_input_patterns')
"     let g:neocomplete#force_omni_input_patterns = {}
" endif
" let g:neocomplete#force_omni_input_patterns.ruby =
"     \ '[^. *\t]\.\w*\|\h\w*::'

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif

" use <Leader>s to go to symbol with Unite. This is to replace CtrlP
" nnoremap <silent> <Leader>s :NeoCompleteIncludeMakeCache<CR>:Unite
"             \ -silent tag/include -start-insert<CR>
nnoremap <silent> <Leader>s :Unite tag -start-insert<CR>

" completefunc of vim-clojure-static interferes with neocomplcache
" https://github.com/guns/vim-clojure-static/issues/32
" let g:neocomplcache_force_overwrite_completefunc = 1
let g:neocomplete#force_overwrite_completefunc = 1

"---end neocomplete }}}
"===============================================================================

"===============================================================================
"---begin neosnippet {{{
"usage:
" C-n or C-p to move around the suggested snippets
" C-k to expand the chosen suggested snippets
" C-k in insert mode to move to next field in the snippets (using Tab is fine
" too)

" Plugin key-mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)

" SuperTab like snippets behavior.
imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: "\<TAB>"

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif


" Enable snipMate compatibility feature.
let g:neosnippet#enable_snipmate_compatibility = 1
" Tell Neosnippet about the other snippets
let g:neosnippet#snippets_directory='~/.vim/bundle/vim-snippets/snippets'

"---end neosnippet }}}
"===============================================================================


"===============================================================================
"---begin vimux {{{
let g:VimuxOrientation = "h"
let g:VimuxHeight = "35"
let g:VimuxPromptString = "Command: "

" Close vim tmux runner opened by VimuxRunCommand
map <Leader>vc :VimuxCloseRunner<CR>

" Inspect runner pane
map <Leader>vi :VimuxInspectRunner<CR>

" Interrupt any command running in the runner pane
map <Leader>vx :VimuxInterruptRunner<CR>

" Prompt for a command to run
map <Leader>vp :VimuxPromptCommand<CR>

" Run the current file with rspec
map <Leader>vr :call MyVimux()<CR>

" for compiling and running Hadoop
map <Leader>vh :call MyHadoop()<CR>

function! VimuxSlime()
  call VimuxSendText(@v)
  call VimuxSendKeys("Enter")
endfunction

" If text is selected, save it in the v buffer and send that buffer it to tmux
vnoremap <Leader>vs "vy :call VimuxSlime()<CR>

function! MyHadoop()
    call ChangeDirToCurrentBuffer()
    let cp = expand('%:p:h') " current path
    let className = expand('%:t:r')

    let cmd = 'hadoop com.sun.tools.javac.Main ' . className . '.java' .
            \ '; jar cf ' . className . '.jar ' . className . '*.class' .
            \ '; hadoop jar ' . className . '.jar '. className . ' input output'

    " send command to change dir to the shell first
    call VimuxRunCommand('cd ' . cp)

    " then run the actual compile/run command
    call VimuxRunCommand(cmd)
endfunction

" compile and run Java file and optionally feed an input text file
function! MyVimux()
    call ChangeDirToCurrentBuffer()
    let cp = expand('%:p:h') " current path

    " try to split the file name by dash character `-`
    let splitDash = split(expand('%:t:r'), '-')
    let className = splitDash[0] " the first element is always the class's name

    if (&filetype ==? 'cpp')
        let cmd = 'g++ ' . expand('%:p') . ' -o a.cout && ./a.cout'
    elseif (&filetype ==? 'c')
        let cmd = 'gcc -std=c99 ' . expand('%:p') . ' -o a.cout && ./a.cout'
    else
        " now handling Java and its stuff

        if len(splitDash) <= 1
            " the current file should be a Java source code

            " now check if the className has the form of xxxxTest
            if (match(className, 'Test$') > 0)
                let cmd = 'rake "test1[' . className . ']"'
            else
                let cmd = "javac " . className . ".java" .
                    \ "; java -cp " .  cp . " " . className
            endif
        else
            " now the current file is a input text file
            let cmd = "javac " . className . ".java" .
                    \ "; java -cp " .  expand('%:p:h') . " " .
                    \ className . " " . expand('%:t')
        endif
    endif

    " send command to change dir to the shell first
    call VimuxRunCommand('cd ' . cp)

    " then run the actual compile/run command
    call VimuxRunCommand(cmd)
endfunction
"---end vimux }}}
"===============================================================================

"===============================================================================
"---begin rainbow_parentheses {{{
" \ ['black',       'SeaGreen3'], << original at 10th
" change it to yellow
" let g:rbpt_colorpairs = [
"     \ ['brown',       'RoyalBlue3'],
"     \ ['Darkblue',    'SeaGreen3'],
"     \ ['darkgray',    'DarkOrchid3'],
"     \ ['darkgreen',   'firebrick3'],
"     \ ['darkcyan',    'RoyalBlue3'],
"     \ ['darkred',     'SeaGreen3'],
"     \ ['darkmagenta', 'DarkOrchid3'],
"     \ ['brown',       'firebrick3'],
"     \ ['gray',        'RoyalBlue3'],
"     \ ['yellow',       'SeaGreen3'],
"     \ ['darkmagenta', 'DarkOrchid3'],
"     \ ['Darkblue',    'firebrick3'],
"     \ ['darkgreen',   'RoyalBlue3'],
"     \ ['darkcyan',    'SeaGreen3'],
"     \ ['darkred',     'DarkOrchid3'],
"     \ ['red',         'firebrick3'],
"     \ ]

" au VimEnter * RainbowParenthesesToggle
" au Syntax * RainbowParenthesesLoadRound
" au Syntax * RainbowParenthesesLoadSquare
" au Syntax * RainbowParenthesesLoadBraces
"---end rainbow_parentheses }}}
"===============================================================================

"===============================================================================
"---begin rainbow {{{
let g:rainbow_active = 1 "0 if you want to enable it later via :RainbowToggle
let g:rainbow_conf = {
    \   'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick'],
    \   'ctermfgs': ['lightblue', 'lightyellow', 'lightcyan', 'lightmagenta'],
    \   'operators': '_,_',
    \   'parentheses': ['start=/(/ end=/)/ fold', 'start=/\[/ end=/\]/ fold',
                \ 'start=/{/ end=/}/ fold'],
    \   'separately': {
    \       '*': {},
    \       'tex': {
    \           'parentheses': ['start=/(/ end=/)/', 'start=/\[/ end=/\]/'],
    \       },
    \       'lisp': {
    \           'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick',
                \ 'darkorchid3'],
    \       },
    \       'vim': {
    \           'parentheses': ['start=/(/ end=/)/', 'start=/\[/ end=/\]/',
                \ 'start=/{/ end=/}/ fold', 'start=/(/ end=/)/ containedin=vimFuncBody',
                \ 'start=/\[/ end=/\]/ containedin=vimFuncBody', 'start=/{/
                \ end=/}/ fold containedin=vimFuncBody'],
    \       },
    \       'html': {
    \           'parentheses': ['start=/\v\<((area|base|br|col|embed|hr|img|
                \ input|keygen|link|menuitem|meta|param|source|track|wbr)
                \ [ >])@!\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"
                \ |'."'".'[^'."'".']*'."'".'|[^ '."'".'"><=`]*))?)*\>/
                \ end=#</\z1># fold'],
    \       },
    \       'css': 0,
    \   }
    \}
"---end rainbow }}}
"===============================================================================

"===============================================================================
"---begin vim-dispatch {{{
function! MyDispatch()
    call ChangeDirToCurrentBuffer()
    :Dispatch!

    " having problem here, sometime the quickfix window is empty and doesn't
    " contain the output result, or it contains the old (previous output)
    " So, comment it out to avoid misleading result!
    " :Copen
    execute "normal \<c-w>L"
endfunction

autocmd FileType java let b:dispatch = 'javac % && java -cp %:p:h %:t:r'
nnoremap <F9> :call MyDispatch()<CR>

" automatic open quickfix window to see result
" autocmd QuickFixCmdPost * copen

" <Leader><Enter> only active on quickfix window (qf) and move it to the right
autocmd! FileType qf nnoremap <buffer> <leader><Enter> <C-w>L
"---end vim-dispatch }}}
"===============================================================================


"===============================================================================
"---begin ctrlp {{{
"Usage:
"  Once ctrlp appeared: press <c-f> and <c-b> to cycle between modes.

""mimic Ctrl+r go to symbol as in Sublime Text
"ref: https://github.com/subvim/subvim/blob/master/vim/base/vimrc
"use C-j and C-k or arrow keys to navigate through the result list
"<c-t> or <c-v>, <c-x> to open the selected entry in a new tab or in a new split.

" Open goto symbol on current buffer
" update 2014-09-17: use Unite instead of this
" nmap <Leader>s :MyCtrlPTag<cr>

"imap <Leader>s<esc>:MyCtrlPTag<cr>


" function MyCtrlPTag()
"     let g:ctrlp_prompt_mappings = {
"     \ 'AcceptSelection("e")': ['<cr>', '<2-LeftMouse>'],
"     \ 'AcceptSelection("t")': ['<c-t>'],
"     \ }
"     CtrlPBufTag
" endfunc
" com! MyCtrlPTag call MyCtrlPTag()


" Open goto symbol on all buffers
nmap <Leader>S :CtrlPBufTagAll<cr>
"imap <Leader>S<esc>:CtrlPBufTagAll<cr>

" Exclude files and directories using Vim's wildignore and CtrlP's own
" g:ctrlp_custom_ignore:
set wildignore+=*/tmp/*,*.so,*.swp,*.zip     " MacOSX/Linux
set wildignore+=*\\tmp\\*,*.swp,*.zip,*.exe  " Windows
let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn)$'
" let g:ctrlp_custom_ignore = {
"    \ 'dir':  '\v[\/]\.(git|hg|svn)$',
"    \ 'file': '\v\.(exe|so|dll)$',
"    \ 'link': 'some_bad_symbolic_links',
"    \ }
"---end ctrlp }}}
"===============================================================================

"===============================================================================
"---begin tagbar {{{
noremap <F2> :TagbarToggle<CR>
inoremap <F2> <ESC> :TagbarToggle<CR>
"---end tagbr }}}
"===============================================================================


"===============================================================================
"---begin commentary {{{
"usage:
" gc{motion} comment/uncomment lines that {motion} moves over
" gcc : comment/uncomment the whole line
" gcgc/gcu : uncomment all the current and adjacent commented lines

" default comment style for cpp
"autocmd FileType cpp set commentstring="/*%s*/"

" now use // instead of /*   */
autocmd FileType cpp set commentstring=//\ %s

" for matlab file:
autocmd FileType matlab set commentstring=\%\ %s

" autocmd FileType py set commentstring=#\ %s
"---end commentary }}}
"===============================================================================


"===============================================================================
"---begin syntastic {{{

"use Ctrl+w E to check error
let g:syntastic_mode_map = { 'mode': 'passive', 'active_filetypes': [],'passive_filetypes': [] }
nnoremap <C-w>E :SyntasticCheck<CR> :SyntasticToggleMode<CR>

" disable checking for cpp file type
let g:syntastic_cpp_checkers=['']

let g:syntastic_disabled_filetypes=['html']


set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
"---end syntastic }}}
"===============================================================================

"===============================================================================
"---begin abolish {{{
"Usage:
"   search and replace "tung le" to "squallltt"
"       :%S/tung le/squallltt/gc
"   other usage:
"       :%Subvert/facilit{y,ies}/building{,s}/g
"       :%Subvert/address{,es}/reference{,s}/g
"
"       Want to turn fooBar into foo_bar? Press crs (coerce to snake_case).
"       MixedCase (crm), camelCase (crc), snake_case (crs), and UPPER_CASE (cru)
"       are all just 3 keystrokes away.

"---end abolish }}}
"===============================================================================

"===============================================================================
"---begin delimitMate {{{
"create line break when pressing enter
let g:delimitMate_expand_cr = 1
let g:delimitMate_expand_space = 1

let delimitMate_jump_expansion = 1
"---end delimitMate }}}
"===============================================================================

"===============================================================================
"---begin vim-session {{{
" let g:session_directory='~/.vim/data/sessions'
let g:session_directory='~/dev/mylinux/nogit/vimdata/sessions'
let g:session_autosave = 'yes'
let g:session_autoload = 'yes'
let g:session_default_to_last = 1
"---end vim-session }}}
"===============================================================================

"===============================================================================
"---begin vim-simple-todo {{{
" Comment out to use <Space> for folding/unfolding because it's more useful than
" this plugin

let g:simple_todo_map_keys = 0
" nmap <Space>i <Plug>(simple-todo-new)
" " imap <Space>i <Plug>(simple-todo-new)

" nmap <Space>o <Plug>(simple-todo-below)
" " imap <Space>o <Plug>(simple-todo-below)

" nmap <Space>O <Plug>(simple-todo-above)
" " imap <Space>O <Plug>(simple-todo-above)

" nmap <Space>x <Plug>(simple-todo-mark-as-done) :nohl<CR>
" " imap <Space>x <Plug>(simple-todo-mark-as-done)

" nmap <Space>X <Plug>(simple-todo-mark-as-undone) :nohl<CR>
" " imap <Space>X <Plug>(simple-todo-mark-as-undone)

"---end vim-simple-todo }}}
"===============================================================================

"===============================================================================
"---begin markdown {{{
" below section need to be at the bottom of the file, or else the auto bullet in
" markdown will not work

" Set *.md file to be markdown filetype instead of modula2 as default
" autocmd BufRead,BufNew,BufNewFile *.md set filetype=markdown
" update 2015-04-27 to use with https://github.com/plasticboy/vim-markdown
autocmd BufRead,BufNew,BufNewFile *.md set filetype=mkd

" http://stackoverflow.com/questions/19211839/markdown-lists-in-vim
autocmd Filetype mkd setlocal com=s1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,b:-,b:+ | set formatoptions+=tcroqln

" make markdown auto insert list with 1. when possible
autocmd Filetype mkd setlocal com+=b:1.

" disable default key mapping of vim-markdown plugin
let g:vim_markdown_no_default_key_mappings=1
"---end markdown }}}
"===============================================================================

"===============================================================================
"---begin dragvisuals.vim {{{
" move the whole visual block (select by pressing <C-v>
vmap  <expr>  <LEFT>   DVB_Drag('left')
vmap  <expr>  <RIGHT>  DVB_Drag('right')
vmap  <expr>  <DOWN>   DVB_Drag('down')
vmap  <expr>  <UP>     DVB_Drag('up')
vmap  <expr>  D        DVB_Duplicate()

" Remove any introduced trailing whitespace after moving...
let g:DVB_TrimWS = 1
"---end dragvisuals.vim }}}
"===============================================================================

"===============================================================================
"---begin vim-sexp {{{
" disable automatically producing closing bracket because we already have it
let g:sexp_enable_insert_mode_mappings = 0
"---end vim-sexp }}}
"===============================================================================

let g:ragtag_global_maps = 1

